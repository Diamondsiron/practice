<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    function Stack(){
        let items = []
        this.push = function(element) {
            items.push(element)
        }
        this.pop = function() {
            return items.pop()
        }
        this.peek = function() {
            return items[items.length-1]
        }
        this.isEmpty = function() {
            return items.length == 0
        }
        this.size = function() {
            return items.length
        }
        this.clear = function() {
            items = []
        }
        this.print = function() {
            console.log(items.toString())
        }
    }
    let stack = new Stack();
    console.log(stack.isEmpty())
    stack.push(5)
    stack.push(8)
    console.log(stack.peek())
    stack.push(11)
    console.log(stack.size())
    console.log(stack.isEmpty())
    stack.push(15)
    stack.pop()
    stack.pop()
    console.log(stack.size())
    stack.print()
    function divideBy2(decNumber) {
        var remStack = new Stack(),
        rem,
        binaryString = '';
        while (decNumber > 0) {
            rem = Math.floor(decNumber % 2);
            remStack.push(rem)
            decNumber = Math.floor(decNumber / 2)
        }
        while (!remStack.isEmpty()) {
            binaryString += remStack.pop().toString();
        }
        return binaryString
    }
    console.log(divideBy2(233))
    console.log(divideBy2(10))
    console.log(divideBy2(1000))
    function Queue() {
        let items = []
        this.enqueue = function(element) {
            items.push(element)
        }
        this.dequeue = function(){
            return items.shift()
        }
        this.front = function() {
            return items[0]
        }
        this.isEmpty = function() {
            return items.length == 0
        }
        this.size = function() {
            return items.length;
        }
        this.print = function() {
            console.log(items.toString())
        }

    }
    let queue = new Queue();
    console.log(queue.isEmpty())
    queue.enqueue('John')
    queue.enqueue('Jack')
    queue.enqueue('Camlia')
    queue.print()
    queue.dequeue()
    queue.dequeue()
    queue.print()
    function LinkedList() {
        let Node  = function(element) {
            this.element = element
            this.next = null
        }
        let length = 0;
        let head = null
        this.append = function(element) {
            let node = new Node(element),
            current;
            if (head === null) {
                head = node
            } else {
                current = head;

                while(current.next) {
                    current = current.next;
                }
                current.next = node;
            }
            length++
        }
        this.insert = function(position, element) {
            if(position >= 0 && position <= length) {
                let node = new node(element),
                current = head,
                previous,
                index = 0;
                
                if(position === 0) {
                    node.next = current;
                    head = node
                }else {
                    while(index++ < position){
                        previous = current;
                        current = current.next
                    }
                    node.next = current;
                    previous.next = node
                }
                length ++
                return true
            }else {
                return false
            }
        }
        this.removeAt = function(position) {
            if(position > -1 && position < length) {
                let current = head,
                previous,
                index = 0;

                if(position === 0) {
                    head = current.next
                }else{
                    while(index++ < position) {
                        previous = current;
                        current = current.next
                    }
                    previous.next = current.next
                }
                length--;
                return current.element
            }else{
                return null
            }
        }
        this.remove = function(element) {
            let index = this.indexOf(element)
            return this.removeAt(index);
        }
        this.indexOf = function(element) {
            let current = head,
            index = -1;
            while(current) {
                if(element == current.element) {
                    return index
                }
                index ++
                current = current.next
            }
            return -1
        }
        this.isEmpty = function() {
            return length === 0
        }
        this.size = function() {
            return length
        }
        this.getHead = function() {
            return head
        }
        this.toString = function() {
            let current = head,
            string = '';
            while(current) {
                string += current.element + (current.next ? 'n' :'');
                current = current.next;
            }
            return string
        }
        this.print = function() {

        }
    }

    let list = new LinkedList();
    list.append(15)
    list.append(10)
    console.log(list.toString())

    function DoublyLinkedList() {
        let node = function(element) {
            this.element = element;
            this.next  = null;
            this.prev = null
        }
        let length = 0;
        let head = null;
        let tail = null;

        this.insert = function(position, element) {
            if(position >= 0 && position <= length) {
                let node = new node(element),
                current = head,
                previous,
                index = 0;
                
                if(position === 0) {
                    if(!head) {
                        head = node 
                        tail = node
                    }else {
                        node.next = current;
                        current.prev = node
                        head = node
                    }
                    
                }else if(position === length) {
                    current = tail;
                    current.next = node;
                    node.prev = current;
                    tail = node
                }else {
                    while(index++ < position){
                        previous = current;
                        current = current.next
                    }
                    node.next = current;
                    previous.next = node
                    current.prev = node;
                    node.prev = previous
                }
                length ++
                return true
            }else {
                return false
            }
        }
        this.removeAt = function(position) {
            if(position > -1 && position < length) {
                let current = head,
                previous,
                index = 0;

                if(position === 0) {
                    head = current.next;
                    if (length === 1){
                        tail = null
                    }else {
                        head.prev = null
                    }
                }else if (position===length-1) {
                    current = tail;
                    tail = current.prev
                    tail.next = null
                }else{
                    while(index++ < position) {
                        previous = current;
                        current = current.next
                    }
                    previous.next = current.next
                    current.next.prev = previous
                }
                length--;
                return current.element
            }else{
                return null
            }
        }
    }

    function Set() {
        let items = {}
        this.has = function(value) {
            //return value in items
            return items.hasOwnProperty(value)
        }
        this.add = function(value) {
            if (!this.has(value)) {
                items[value] = value;
                return true
            }
            return false
        }
        this.remove = function(value) {
            if(this.has(value)) {
                delete items[value]
                return true
            }
            return false
        }
        this.clear = function() {
            items = {}
        }
        this.size = function() {
            return Object.keys(items).length;
        }
        this.values = function() {
            let values = [];
            for(let key in items) {
                if(items.hasOwnProperty(key)) {
                    values.push(items[key])
                }
            }
            return values
        }
        this.union = function(otherSet) {
            let unionSet = new Set();
            let values = this.values();
            for(let i = 0; i < values.length; i++) {
                unionSet.add(values[i])
            }
            values = otherSet.values()
            for (let i = 0; i < values.length; i++) {
                unionSet.add(values[i])
            }
            return unionSet;
        }
        this.intersection = function(otherSet) {
            let intersectionSet = new Set()
            let values = this.values()
            for (let i = 0; i < values.length; i++) {
                if(otherSet.has(values[i])) {
                    intersectionSet.add(values[i])
                }
            }
            return intersectionSet
        }
        this.difference = function(otherSet) {
            let differenceSet = new Set()
            let values = this.values;
            for (let i = 0; i < values.length; i++) {
                if (!otherSet.has(values[i])) {
                    differenceSet.add(values[i])
                }
            }
            return differenceSet
        }
        this.subset = function(otherSet) {
            if(this.size() > otherSet.size()){
                return false
            } else {
                let values = this.values()
                for (let i = 0; i < values.length; i++) {
                    if (!otherSet.has(values[i])) {
                        return false
                    }
                }
            }
            return true
        }

    }
    let set = new Set();
    set.add(1)
    console.log(set.values()); //输出["1"]
    console.log(set.has(1)); //输出true
    console.log(set.size()); //输出1
    set.add(2);
    console.log(set.values()); //输出["1", "2"]
    console.log(set.has(2)); //true
    console.log(set.size()); //2
    set.remove(1);
    console.log(set.values()); //输出["2"]
    set.remove(2);
    console.log(set.values()); //输出[]
    let setA = new Set();
    setA.add(1);
    setA.add(2);
    setA.add(3);
    let setB = new Set();
    setB.add(3);
    setB.add(4);
    setB.add(5);
    setB.add(6);
    let unionAB = setA.union(setB);
    console.log(unionAB.values());
    let intersectionAB = setA.intersection(setB);
    console.log(intersectionAB.values());
    let differenceAB = setA.difference(setB);
    console.log(differenceAB.values());
    console.log(setA.subset(setB));
    
    function Dictionary() {
        let items = {}
        this.has = function(key) {
            return key in items
        }
        this.set = function(key, value) {
            items[key] = value
        }
        this.delete = function(key) {
            if (this.has(key)) {
                delete items[key]
                return true
            }
            return false
        }
        this.get = function(key) {
            return this.has(key) ? items[key] : undefined
        }
        this.values = function() {
            var values = []
            for(let k in items) {
                if (this.has(k)) {
                    values.push(items[k])
                }
            }
            return values
        }
        this.keys = function() {
            return Object.keys(items)
        }
        this.getItems = function () {
            return items
        }
    }
    var dictionary = new Dictionary();
    dictionary.set('Gandalf', 'gandalf@email.com');
    dictionary.set('John', 'johnsnow@email.com');
    dictionary.set('Tyrion', 'tyrion@email.com');
    dictionary.delete('John');

    function HashTable() {
        var table = []
        var loseloseHashCode = function (key) {
            var hash = 0;
            for (var i = 0; i < key.length; i++) {
                hash += key.charCodeAt(i)
            }
            return hash % 37
        }
        var djb2HashCode = function (key) {
            var hash = 5381
            for (var i = 0; i < key.length; i++) {
                hash = hash * 33 +  key.charCodeAt(i)
            }
            return hash % 1013
        }
        var ValuePair = function(key, value) {
            this.key = key;
            this.value = value
            this.toString = function() {
                return '[' + this.key + '-' + this.value + ']'
            }
        }
        this.put = function (key, value) {
            var position = djb2HashCode(key)
            if (table[position] == undefined) {
                table[position] = new ValuePair(key, value)
            } else {
                var index = ++position
                while (table[position] != undefined) {
                    index ++
                }
                table[index] = new ValuePair(key, value)
            }
           
        }
        this.get = function (key) {
            var position = djb2HashCode(key)
            if (table[position] !== undefined) {
               if (table[position].key === key) {
                   return table[position].value
               } else {
                   var index = ++position
                   while (table[index] === undefined || table[index].key !== key) {
                       index ++
                   }
                   if (table[index].key == key) {
                       return table[index].value
                   }
               }
            }
            return undefined
        }
        this.remove = function (key) {
            var position = djb2HashCode(key)
            if (table[position] !== undefined) {
               if (table[position].key === key) {
                    table[position] = undefined
               } else {
                   var index = ++position
                   while (table[index] === undefined || table[index].key !== key) {
                       index ++
                   }
                   if (table[index].key == key) {
                       table[index] = undefined
                   }
               }
            }
            return undefined
        }
        this.print = function () {
            for (var i = 0; i < table.length; ++i) {
                if (table[i] !== undefined) {
                    console.log(i + ":" + table[i])
                }
            }
        }
        
    }
    var hash = new HashTable();
    hash.put('Gandalf', 'gandalf@email.com');
    hash.put('John', 'johnsnow@email.com');
    hash.put('Tyrion', 'tyrion@email.com');
    hash.put('Aaron', 'aaron@email.com');
    hash.put('Donnie', 'donnie@email.com');
    hash.put('Ana', 'ana@email.com');
    hash.put('Jonathan', 'jonathan@email.com');
    hash.put('Jamie', 'jamie@email.com');
    hash.put('Sue', 'sue@email.com');
    hash.put('Mindy', 'mindy@email.com');
    hash.put('Paul', 'paul@email.com');
    hash.put('Nathan', 'nathan@email.com');
    hash.print();

    function BinarySearchTree() {
        var Node = function(key) {
            this.key = key;
            this.left = null;
            this.right = null
        }
        var root = null;

        this.insert = function(key) {
            var newNode = new Node(key)
            if (root === null) {
                root = newNode
            } else {
                insertNode(root, newNode)
            }
        }
        
        var insertNode = function(node, newNode) {
            if (newNode.key < node.key) {
                if (node.left === null) {
                    node.left = newNode
                } else {
                    insertNode(node.left, newNode)
                }
            } else {
                if (node.right === null) {
                    node.right = newNode
                } else {
                    insertNode(node.right, newNode)
                }
            }
        }

        this.inOrderTraverse = function(callback) {
            inOrderTraverseNode(root, callback)
        }

        var inOrderTraverseNode = function(node, callback) {
            if (node !== null) {
                inOrderTraverseNode(node.left, callback)
                callback(node.key)
                inOrderTraverseNode(node.right, callback)
            }
        }
        
        this.preOrderTraverse = function(callback) {
            preOrderTraverseNode(root, callback)
        }

        var preOrderTraverseNode = function(node, callback) {
            if (node !== null) {
                callback(node.key);
                preOrderTraverseNode(node.left, callback)
                preOrderTraverseNode(node.right, callback)
            }
        }

        this.postOrderTraverse = function(callback) {
            postOrderTraverseNode(root, callback)
        }

        var postOrderTraverseNode = function(node, callback) {
            if (node !== null) {
                postOrderTraverseNode(node.left, callback)
                postOrderTraverseNode(node.right, callback)
                callback(node.key)
            }
        }

        this.min = function() {
            return minNode(root)
        }

        var minNode = function(node) {
            if (node) {
                while (node && node.left !== null) {
                    node = node.left
                }
                return node.key
            }
            return null
        }

        this.max = function() {
            return maxNode(root)
        }

        var maxNode = function(node) {
            if (node) {
                while (node && node.right !== null) {
                    node = node.right
                }
                return node.key
            }
            return null
        }

        this.search = function(key) {
            return searchNode(root, key)
        }

        var searchNode = function(node, key) {
            if (node == null) {
                return false
            }
            if (key < node.key) {
                return searchNode(node.left, key)
            } else if (key > node.key) {
                return searchNode(node.right, key)
            } else {
                return true
            }

        }

        this.remove = function(key) {
            root = removeNode(root, key)
        }

        var removeNode = function(node, key) {
            if (node == null) {
                return null
            }
            if (key < node.key) {
                node.left = removeNode(node.left, key)
                return node
            } else if (key > node.key) {
                node.right = removeNode(node.right, key)
                return node
            } else {
                if (node.left === null && node.right === null) {
                    node = null;
                    return node
                } else if (node.left === null) {
                    node = node.right;
                    return node
                } 
                var axu = findMinNode(node.right)
                node.key = aux.key
                node.right = removeNode(node.right, aux.key);
                return node
            }
        }

        var findMinNode = function(node) {
            while (node && node.left != null) {
                node = node.left
            }
            return node
        }

    }
    function printNode(value) {
        console.log(value)
    }
    var tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7);
    tree.insert(15);
    tree.insert(5);
    tree.insert(3);
    tree.insert(9);
    tree.insert(8);
    tree.insert(10);
    tree.insert(13);
    tree.insert(12);
    tree.insert(14);
    tree.insert(20);
    tree.insert(18);
    tree.insert(25);
    tree.insert(6);
    tree.inOrderTraverse(printNode)
    tree.preOrderTraverse(printNode)
    tree.postOrderTraverse(printNode)
    console.log(tree.min(),tree.max())
    console.log(tree.search(1) ? 'Key 1 found.' : 'Key 1 not found.');
    console.log(tree.search(8) ? 'Key 8 found.' : 'Key 8 not found.');


    function Graph() {
        var vertices = []
        var adjList = new Dictionary()

        this.addVertex = function(v) {
            vertices.push(v)
            adjList.set(v,[])
        }

        this.addEdge = function(v, w) {
            adjList.get(v).push(w)
            adjList.get(w).push(v)
        }

        this.toString = function() {
            var s = '';
            for (var i = 0; i < vertices.length; i++) {
                s += vertices[i] + '->';
                var neighbors = adjList.get(vertices[i]);
                for (var j = 0; j < neighbors.length; j++) {
                    s += neighbors[j] + ' ';
                }
                s += '\n'
            }
            return s
        }

        var initializeColor = function() {
            var color = [];
            for (var i = 0; i < vertices.length; i++) {
                color[vertices[i]] = 'white'
            }
            return color
        }

        this.bfs = function(v, callback) {
            var color = initializeColor();
            queue = new Queue
            queue.enqueue(v)

            while (!queue.isEmpty()) {
                var u = queue.dequeue();
                neighbors = adjList.get(u)
                color[u] = 'grey'
                for (var i = 0; i < neighbors.length; i++) {
                    var w = neighbors[i];
                    if (color[w] === 'white') {
                        color[w] = 'grey'
                        queue.enqueue(w)
                    }
                }
                color[u] = 'black'
                if (callback) {
                    callback(u)
                }
            }
        }

        this.BFS = function(v) {
            var color = initializeColor();
            queue = new Queue,
            d = [],
            pred = [];
            queue.enqueue(v)

            for (var i = 0; i < vertices.length; i++) {
                d[vertices[i]] = 0;
                pred[vertices[i]] = null
            }

            while (!queue.isEmpty()) {
                var u = queue.dequeue();
                neighbors = adjList.get(u)
                color[u] = 'grey'
                for (var i = 0; i < neighbors.length; i++) {
                    var w = neighbors[i];
                    if (color[w] === 'white') {
                        color[w] = 'grey'
                        d[w] = d[u] + 1
                        pred[w] = u
                        queue.enqueue(w)
                    }
                }
                color[u] = 'black'
                return {
                    distances : d,
                    predcessors : pred
                }
            }
        }

        this.dfs = function(callback) {
            var color = initializeColor()

            for (var i = 0; i < vertices.length; i++) {
                if (color[vertices[i]] === 'white') {
                    dfsVisit(vertices[i], color, callback)
                }
            }
        }

        var dfsVisit = function(u, color, callback) {
            color[u] = 'grey';
            if (callback) {
                callback(u)
            }
            var neighbors = adjList.get(u)
            for (var i = 0; i < neighbors.left; i++) {
                var w = neighbors[i]
                if (color[w] === 'white') {
                    dfsVisit(w, color, callback)
                }
            }
            color[u] = 'black'
        }

        var time = 0;
        this.DFS = function() {
            var color = initializeColor();
            d = [],
            f = [],
            p = [],
            time = 0;

            for (var i = 0; i < vertices.length; i++) {
                f[vertices[i]]  = 0
                d[vertices[i]]  = 0
                p[vertices[i]]  = null
            }
            for (var i = 0; i < vertices.length; i++) {
                if (color[vertices[i]] === 'white') {
                    DFSVisit(vertices[i], color, d, f, p)
                }
            }
            return {
                discovery : d,
                finished : f,
                predcessors : p
            }
        }

        var DFSVisit = function(u, color, d, f, q) {
            console.log('discovered' + u);
            color[u] = 'grey';
            d[u] = ++time;
            var neighbors = adjList.get(u)
            for (var i = 0; i < neighbors.length; i++) {
                var w = neighbors[i];
                if (color[w] === 'white') {
                    p[w] = u;
                    DFSVisit(w, color, d, f, p)
                }
            }
            color[u] = 'black'
            f[u] = ++time;
            console.log('explored' + u)
        }
        var INF = Number.MAX_SAFE_INTEGER
        //计算最短路径的Dijkstra算法和Floyd-Warshall算法，以及计算图的最小生成树的Prim算法和Kruskal算法
        this.dijkstra = function(src) {
            var dist = [],
            visited = [],
            length = this.graph.length

            for (var i = 0; i < length; i++) {
                dist[i] = INF;
                visited[i] = false
            }
            dist[src] = 0
            for (var i = 0; i < length -1; i++) {
                var u = minDistance(dist, visited)
                visited[u] = true
                for (var v = 0; v < length; v++) {
                    if (!visited[v] && this.graph[u][v] != 0 && dist[u] !=INF && dist[u] + this.graph[u][v] < dist[v]) {
                        dist[v] = dist[u] + this.graph[u][v]
                    }
                }
            }
            return dist
        }

        var minDistance = function(dist, visited) {
            var min = INF, minIndex = -1;
            for (var v = 0; v < dist.length; v++) {
                if (visited[v] == false && dist[v] <= min){
                    min = dist[v];
                    minIndex = v
                }
                
            }
            return minIndex;
        }

        this.floydWarshall = function() {
            var dist = [],
            length = this.graph.length,
            i, 
            j,
            k
            for (i = 0; i < length; i++) {
                dist[i] = [];
                for (j = 0; j < length; j++) {
                    dist[i][j] = this.graph[i][j]
                }
            }
            for (k = 0; k < length; k++) {
                for (i = 0; i < length; i++) {
                    for (j = 0; j < length; j++) {
                        if (dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j]
                        }
                    }
                }
            }
            return dist
        }

        this.prim = function() {
            var parent = [],
            key = [],
            visited = [],
            length = this.graph.length,
            i;
            for (i = 0; i < length; i++) {
                key[i] = INF;
                visited[i] = false
            }
            key[0] = 0
            parent[0] = -1
            for (i = 0; i < length-1; i++) {
                var u  = minkey(key, visited)
                visited[u] = true
                for (var v = 0; v < length; v++) {
                    if (this.graph[u][v] && visited[v] == false && this.graph[u][v] < key[v]) {
                        parent[v] = u
                        key[v] = this.graph[u][v]
                    }
                }
            }
            return parent
        }

        this.kruskal = function() {
            var length = this.graph.length,
            parent = [],
            cost,
            ne = 0,
            a,
            b,
            u,
            v,
            i,
            j,
            min;
            cost = initializeCost()

            while (ne < length - 1) {
                for (i = 0, min = INF; i<length; i++) {
                    for (j = 0; j < length; j++) {
                        if (cost[i][j] < min) {
                            min = cost[i][j]
                            u = i
                            v = j
                        }
                    }
                }
                u = find(u, parent)
                v = find(v, parent)
                if(union(u, v, parent)) {
                    ne++
                }
                cost[u][v] = cost[v][u] = INF
            }
            return parent
        }

        var find = function(i, parent) {
            while (parent[i]) {
                i = parent[i]
            }
            return i
        }

        var union = function(i, j, parent) {
            if (i != j) {
                parent[j] = i
                return true
            }
            return false
        }

    }
    
    var graph = new Graph();
    var myVertices = ['A','B','C','D','E','F','G','H','I']; //{7}
    for (var i=0; i<myVertices.length; i++){ //{8}
        graph.addVertex(myVertices[i]);
    }
    graph.addEdge('A', 'B'); //{9}
    graph.addEdge('A', 'C');
    graph.addEdge('A', 'D');
    graph.addEdge('C', 'D');
    graph.addEdge('C', 'G');
    graph.addEdge('D', 'G');
    graph.addEdge('D', 'H');
    graph.addEdge('B', 'E');
    graph.addEdge('B', 'F');
    graph.addEdge('E', 'I');
    console.log(graph.toString());
    function printNode(value) {
        console.log('Visited vertex:' + value)
    }
    graph.bfs(myVertices[0], printNode);
    var shortestPathA = graph.BFS(myVertices[0]);
    console.log(shortestPathA);
    var formVertex = myVertices[0]
    // for (var i = 0; i < myVertices.length; i++) {
    //     var toVertex = myVertices[i];
    //     path = new Stack();
    //     for (var v = toVertex; v !== formVertex; v = shortestPathA.predcessors[v]) {
    //         path.push(v)
    //     }
    //     path.push(formVertex)
    //     var s = path.pop();
    //     while (!path.isEmpty()) {
    //         s += '-' + path.pop();
    //     }
    //     console.log(s)
    // }
    graph.dfs(printNode);
    graph.DFS();
    var graph = [[0, 2, 4, 0, 0, 0],
                [0, 0, 1, 4, 2, 0],
                [0, 0, 0, 0, 3, 0],
                [0, 0, 0, 0, 0, 2],
                [0, 0, 0, 3, 0, 2],
                [0, 0, 0, 0, 0, 0]];
    //graph.dijkstra()
    </script>
</body>
</html>
