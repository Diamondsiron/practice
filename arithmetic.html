<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    function Stack(){
        let items = []
        this.push = function(element) {
            items.push(element)
        }
        this.pop = function() {
            return items.pop()
        }
        this.peek = function() {
            return items[items.length-1]
        }
        this.isEmpty = function() {
            return items.length == 0
        }
        this.size = function() {
            return items.length
        }
        this.clear = function() {
            items = []
        }
        this.print = function() {
            console.log(items.toString())
        }
    }
    let stack = new Stack();
    console.log(stack.isEmpty())
    stack.push(5)
    stack.push(8)
    console.log(stack.peek())
    stack.push(11)
    console.log(stack.size())
    console.log(stack.isEmpty())
    stack.push(15)
    stack.pop()
    stack.pop()
    console.log(stack.size())
    stack.print()
    function divideBy2(decNumber) {
        var remStack = new Stack(),
        rem,
        binaryString = '';
        while (decNumber > 0) {
            rem = Math.floor(decNumber % 2);
            remStack.push(rem)
            decNumber = Math.floor(decNumber / 2)
        }
        while (!remStack.isEmpty()) {
            binaryString += remStack.pop().toString();
        }
        return binaryString
    }
    console.log(divideBy2(233))
    console.log(divideBy2(10))
    console.log(divideBy2(1000))
    function Queue() {
        let items = []
        this.enqueue = function(element) {
            items.push(element)
        }
        this.dequeue = function(){
            return items.shift()
        }
        this.front = function() {
            return items[0]
        }
        this.isEmpty = function() {
            return items.length == 0
        }
        this.size = function() {
            return items.length;
        }
        this.print = function() {
            console.log(items.toString())
        }

    }
    let queue = new Queue();
    console.log(queue.isEmpty())
    queue.enqueue('John')
    queue.enqueue('Jack')
    queue.enqueue('Camlia')
    queue.print()
    queue.dequeue()
    queue.dequeue()
    queue.print()
    function LinkedList() {
        let Node  = function(element) {
            this.element = element
            this.next = null
        }
        let length = 0;
        let head = null
        this.append = function(element) {
            let node = new Node(element),
            current;
            if (head === null) {
                head = node
            } else {
                current = head;

                while(current.next) {
                    current = current.next;
                }
                current.next = node;
            }
            length++
        }
        this.insert = function(position, element) {
            if(position >= 0 && position <= length) {
                let node = new node(element),
                current = head,
                previous,
                index = 0;
                
                if(position === 0) {
                    node.next = current;
                    head = node
                }else {
                    while(index++ < position){
                        previous = current;
                        current = current.next
                    }
                    node.next = current;
                    previous.next = node
                }
                length ++
                return true
            }else {
                return false
            }
        }
        this.removeAt = function(position) {
            if(position > -1 && position < length) {
                let current = head,
                previous,
                index = 0;

                if(position === 0) {
                    head = current.next
                }else{
                    while(index++ < position) {
                        previous = current;
                        current = current.next
                    }
                    previous.next = current.next
                }
                length--;
                return current.element
            }else{
                return null
            }
        }
        this.remove = function(element) {
            let index = this.indexOf(element)
            return this.removeAt(index);
        }
        this.indexOf = function(element) {
            let current = head,
            index = -1;
            while(current) {
                if(element == current.element) {
                    return index
                }
                index ++
                current = current.next
            }
            return -1
        }
        this.isEmpty = function() {
            return length === 0
        }
        this.size = function() {
            return length
        }
        this.getHead = function() {
            return head
        }
        this.toString = function() {
            let current = head,
            string = '';
            while(current) {
                string += current.element + (current.next ? 'n' :'');
                current = current.next;
            }
            return string
        }
        this.print = function() {

        }
    }

    let list = new LinkedList();
    list.append(15)
    list.append(10)
    console.log(list.toString())

    function DoublyLinkedList() {
        let node = function(element) {
            this.element = element;
            this.next  = null;
            this.prev = null
        }
        let length = 0;
        let head = null;
        let tail = null;

        this.insert = function(position, element) {
            if(position >= 0 && position <= length) {
                let node = new node(element),
                current = head,
                previous,
                index = 0;
                
                if(position === 0) {
                    if(!head) {
                        head = node 
                        tail = node
                    }else {
                        node.next = current;
                        current.prev = node
                        head = node
                    }
                    
                }else if(position === length) {
                    current = tail;
                    current.next = node;
                    node.prev = current;
                    tail = node
                }else {
                    while(index++ < position){
                        previous = current;
                        current = current.next
                    }
                    node.next = current;
                    previous.next = node
                    current.prev = node;
                    node.prev = previous
                }
                length ++
                return true
            }else {
                return false
            }
        }
        this.removeAt = function(position) {
            if(position > -1 && position < length) {
                let current = head,
                previous,
                index = 0;

                if(position === 0) {
                    head = current.next;
                    if (length === 1){
                        tail = null
                    }else {
                        head.prev = null
                    }
                }else if (position===length-1) {
                    current = tail;
                    tail = current.prev
                    tail.next = null
                }else{
                    while(index++ < position) {
                        previous = current;
                        current = current.next
                    }
                    previous.next = current.next
                    current.next.prev = previous
                }
                length--;
                return current.element
            }else{
                return null
            }
        }
    }

    function Set() {
        let items = {}
        this.has = function(value) {
            //return value in items
            return items.hasOwnProperty(value)
        }
        this.add = function(value) {
            if (!this.has(value)) {
                items[value] = value;
                return true
            }
            return false
        }
        this.remove = function(value) {
            if(this.has(value)) {
                delete items[value]
                return true
            }
            return false
        }
        this.clear = function() {
            items = {}
        }
        this.size = function() {
            return Object.keys(items).length;
        }
        this.values = function() {
            let values = [];
            for(let key in items) {
                if(items.hasOwnProperty(key)) {
                    values.push(items[key])
                }
            }
            return values
        }
        this.union = function(otherSet) {
            let unionSet = new Set();
            let values = this.values();
            for(let i = 0; i < values.length; i++) {
                unionSet.add(values[i])
            }
            values = otherSet.values()
            for (let i = 0; i < values.length; i++) {
                unionSet.add(values[i])
            }
            return unionSet;
        }
        this.intersection = function(otherSet) {
            let intersectionSet = new Set()
            let values = this.values()
            for (let i = 0; i < values.length; i++) {
                if(otherSet.has(values[i])) {
                    intersectionSet.add(values[i])
                }
            }
            return intersectionSet
        }
        this.difference = function(otherSet) {
            let differenceSet = new Set()
            let values = this.values;
            for (let i = 0; i < values.length; i++) {
                if (!otherSet.has(values[i])) {
                    differenceSet.add(values[i])
                }
            }
            return differenceSet
        }
        this.subset = function(otherSet) {
            if(this.size() > otherSet.size()){
                return false
            } else {
                let values = this.values()
                for (let i = 0; i < values.length; i++) {
                    if (!otherSet.has(values[i])) {
                        return false
                    }
                }
            }
            return true
        }

    }
    let set = new Set();
    set.add(1)
    console.log(set.values()); //输出["1"]
    console.log(set.has(1)); //输出true
    console.log(set.size()); //输出1
    set.add(2);
    console.log(set.values()); //输出["1", "2"]
    console.log(set.has(2)); //true
    console.log(set.size()); //2
    set.remove(1);
    console.log(set.values()); //输出["2"]
    set.remove(2);
    console.log(set.values()); //输出[]
    let setA = new Set();
    setA.add(1);
    setA.add(2);
    setA.add(3);
    let setB = new Set();
    setB.add(3);
    setB.add(4);
    setB.add(5);
    setB.add(6);
    let unionAB = setA.union(setB);
    console.log(unionAB.values());
    let intersectionAB = setA.intersection(setB);
    console.log(intersectionAB.values());
    let differenceAB = setA.difference(setB);
    console.log(differenceAB.values());
    console.log(setA.subset(setB));
    
    function Dictionary() {
        let items = {}
        this.has = function(key) {
            return key in items
        }
        this.set = function(key, value) {
            items[key] = value
        }
        this.delete = function(key) {
            if (this.has(key)) {
                delete items[key]
                return true
            }
            return false
        }
        this.get = function(key) {
            return this.has(key) ? items[key] : undefined
        }
        this.values = function() {
            var values = []
            for(let k in items) {
                if (this.has(k)) {
                    values.push(items[k])
                }
            }
            return values
        }
        this.keys = function() {
            return Object.keys(items)
        }
        this.getItems = function () {
            return items
        }
    }
    var dictionary = new Dictionary();
    dictionary.set('Gandalf', 'gandalf@email.com');
    dictionary.set('John', 'johnsnow@email.com');
    dictionary.set('Tyrion', 'tyrion@email.com');
    dictionary.delete('John');

    function HashTable() {
        var table = []
        var loseloseHashCode = function (key) {
            var hash = 0;
            for (var i = 0; i < key.length; i++) {
                hash += key.charCodeAt(i)
            }
            return hash % 37
        }
        var djb2HashCode = function (key) {
            var hash = 5381
            for (var i = 0; i < key.length; i++) {
                hash = hash * 33 +  key.charCodeAt(i)
            }
            return hash % 1013
        }
        var ValuePair = function(key, value) {
            this.key = key;
            this.value = value
            this.toString = function() {
                return '[' + this.key + '-' + this.value + ']'
            }
        }
        this.put = function (key, value) {
            var position = djb2HashCode(key)
            if (table[position] == undefined) {
                table[position] = new ValuePair(key, value)
            } else {
                var index = ++position
                while (table[position] != undefined) {
                    index ++
                }
                table[index] = new ValuePair(key, value)
            }
           
        }
        this.get = function (key) {
            var position = djb2HashCode(key)
            if (table[position] !== undefined) {
               if (table[position].key === key) {
                   return table[position].value
               } else {
                   var index = ++position
                   while (table[index] === undefined || table[index].key !== key) {
                       index ++
                   }
                   if (table[index].key == key) {
                       return table[index].value
                   }
               }
            }
            return undefined
        }
        this.remove = function (key) {
            var position = djb2HashCode(key)
            if (table[position] !== undefined) {
               if (table[position].key === key) {
                    table[position] = undefined
               } else {
                   var index = ++position
                   while (table[index] === undefined || table[index].key !== key) {
                       index ++
                   }
                   if (table[index].key == key) {
                       table[index] = undefined
                   }
               }
            }
            return undefined
        }
        this.print = function () {
            for (var i = 0; i < table.length; ++i) {
                if (table[i] !== undefined) {
                    console.log(i + ":" + table[i])
                }
            }
        }
        
    }
    var hash = new HashTable();
    hash.put('Gandalf', 'gandalf@email.com');
    hash.put('John', 'johnsnow@email.com');
    hash.put('Tyrion', 'tyrion@email.com');
    hash.put('Aaron', 'aaron@email.com');
    hash.put('Donnie', 'donnie@email.com');
    hash.put('Ana', 'ana@email.com');
    hash.put('Jonathan', 'jonathan@email.com');
    hash.put('Jamie', 'jamie@email.com');
    hash.put('Sue', 'sue@email.com');
    hash.put('Mindy', 'mindy@email.com');
    hash.put('Paul', 'paul@email.com');
    hash.put('Nathan', 'nathan@email.com');
    hash.print();

    function BinarySearchTree() {
        var Node = function(key) {
            this.key = key;
            this.left = null;
            this.right = null
        }
        var root = null;

        this.insert = function(key) {
            var newNode = new Node(key)
            if (root === null) {
                root = newNode
            } else {
                insertNode(root, newNode)
            }
        }
        
        var insertNode = function(node, newNode) {
            if (newNode.key < node.key) {
                if (node.left === null) {
                    node.left = newNode
                } else {
                    insertNode(node.left, newNode)
                }
            } else {
                if (node.right === null) {
                    node.right = newNode
                } else {
                    insertNode(node.right, newNode)
                }
            }
        }

        this.inOrderTraverse = function(callback) {
            inOrderTraverseNode(root, callback)
        }

        var inOrderTraverseNode = function(node, callback) {
            if (node !== null) {
                inOrderTraverseNode(node.left, callback)
                callback(node.key)
                inOrderTraverseNode(node.right, callback)
            }
        }
        
        this.preOrderTraverse = function(callback) {
            preOrderTraverseNode(root, callback)
        }

        var preOrderTraverseNode = function(node, callback) {
            if (node !== null) {
                callback(node.key);
                preOrderTraverseNode(node.left, callback)
                preOrderTraverseNode(node.right, callback)
            }
        }

        this.postOrderTraverse = function(callback) {
            postOrderTraverseNode(root, callback)
        }

        var postOrderTraverseNode = function(node, callback) {
            if (node !== null) {
                postOrderTraverseNode(node.left, callback)
                postOrderTraverseNode(node.right, callback)
                callback(node.key)
            }
        }

        this.min = function() {
            return minNode(root)
        }

        var minNode = function(node) {
            if (node) {
                while (node && node.left !== null) {
                    node = node.left
                }
                return node.key
            }
            return null
        }

        this.max = function() {
            return maxNode(root)
        }

        var maxNode = function(node) {
            if (node) {
                while (node && node.right !== null) {
                    node = node.right
                }
                return node.key
            }
            return null
        }

        this.search = function(key) {
            return searchNode(root, key)
        }

        var searchNode = function(node, key) {
            if (node == null) {
                return false
            }
            if (key < node.key) {
                return searchNode(node.left, key)
            } else if (key > node.key) {
                return searchNode(node.right, key)
            } else {
                return true
            }

        }

        this.remove = function(key) {
            root = removeNode(root, key)
        }

        var removeNode = function(node, key) {
            if (node == null) {
                return null
            }
            if (key < node.key) {
                node.left = removeNode(node.left, key)
                return node
            } else if (key > node.key) {
                node.right = removeNode(node.right, key)
                return node
            } else {
                if (node.left === null && node.right === null) {
                    node = null;
                    return node
                } else if (node.left === null) {
                    node = node.right;
                    return node
                } 
                var axu = findMinNode(node.right)
                node.key = aux.key
                node.right = removeNode(node.right, aux.key);
                return node
            }
        }

        var findMinNode = function(node) {
            while (node && node.left != null) {
                node = node.left
            }
            return node
        }

    }
    function printNode(value) {
        console.log(value)
    }
    var tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7);
    tree.insert(15);
    tree.insert(5);
    tree.insert(3);
    tree.insert(9);
    tree.insert(8);
    tree.insert(10);
    tree.insert(13);
    tree.insert(12);
    tree.insert(14);
    tree.insert(20);
    tree.insert(18);
    tree.insert(25);
    tree.insert(6);
    tree.inOrderTraverse(printNode)
    tree.preOrderTraverse(printNode)
    tree.postOrderTraverse(printNode)
    console.log(tree.min(),tree.max())
    console.log(tree.search(1) ? 'Key 1 found.' : 'Key 1 not found.');
    console.log(tree.search(8) ? 'Key 8 found.' : 'Key 8 not found.');


    function Graph() {
        var vertices = []
        var adjList = new Dictionary()

        this.addVertex = function(v) {
            vertices.push(v)
            adjList.set(v,[])
        }

        this.addEdge = function(v, w) {
            adjList.get(v).push(w)
            adjList.get(w).push(v)
        }

        this.toString = function() {
            var s = '';
            for (var i = 0; i < vertices.length; i++) {
                s += vertices[i] + '->';
                var neighbors = adjList.get(vertices[i]);
                for (var j = 0; j < neighbors.length; j++) {
                    s += neighbors[j] + ' ';
                }
                s += '\n'
            }
            return s
        }

        var initializeColor = function() {
            var color = [];
            for (var i = 0; i < vertices.length; i++) {
                color[vertices[i]] = 'white'
            }
            return color
        }

        this.bfs = function(v, callback) {
            var color = initializeColor();
            queue = new Queue
            queue.enqueue(v)

            while (!queue.isEmpty()) {
                var u = queue.dequeue();
                neighbors = adjList.get(u)
                color[u] = 'grey'
                for (var i = 0; i < neighbors.length; i++) {
                    var w = neighbors[i];
                    if (color[w] === 'white') {
                        color[w] = 'grey'
                        queue.enqueue(w)
                    }
                }
                color[u] = 'black'
                if (callback) {
                    callback(u)
                }
            }
        }

        this.BFS = function(v) {
            var color = initializeColor();
            queue = new Queue,
            d = [],
            pred = [];
            queue.enqueue(v)

            for (var i = 0; i < vertices.length; i++) {
                d[vertices[i]] = 0;
                pred[vertices[i]] = null
            }

            while (!queue.isEmpty()) {
                var u = queue.dequeue();
                neighbors = adjList.get(u)
                color[u] = 'grey'
                for (var i = 0; i < neighbors.length; i++) {
                    var w = neighbors[i];
                    if (color[w] === 'white') {
                        color[w] = 'grey'
                        d[w] = d[u] + 1
                        pred[w] = u
                        queue.enqueue(w)
                    }
                }
                color[u] = 'black'
                return {
                    distances : d,
                    predcessors : pred
                }
            }
        }

        this.dfs = function(callback) {
            var color = initializeColor()

            for (var i = 0; i < vertices.length; i++) {
                if (color[vertices[i]] === 'white') {
                    dfsVisit(vertices[i], color, callback)
                }
            }
        }

        var dfsVisit = function(u, color, callback) {
            color[u] = 'grey';
            if (callback) {
                callback(u)
            }
            var neighbors = adjList.get(u)
            for (var i = 0; i < neighbors.left; i++) {
                var w = neighbors[i]
                if (color[w] === 'white') {
                    dfsVisit(w, color, callback)
                }
            }
            color[u] = 'black'
        }

        var time = 0;
        this.DFS = function() {
            var color = initializeColor();
            d = [],
            f = [],
            p = [],
            time = 0;

            for (var i = 0; i < vertices.length; i++) {
                f[vertices[i]]  = 0
                d[vertices[i]]  = 0
                p[vertices[i]]  = null
            }
            for (var i = 0; i < vertices.length; i++) {
                if (color[vertices[i]] === 'white') {
                    DFSVisit(vertices[i], color, d, f, p)
                }
            }
            return {
                discovery : d,
                finished : f,
                predcessors : p
            }
        }

        var DFSVisit = function(u, color, d, f, q) {
            console.log('discovered' + u);
            color[u] = 'grey';
            d[u] = ++time;
            var neighbors = adjList.get(u)
            for (var i = 0; i < neighbors.length; i++) {
                var w = neighbors[i];
                if (color[w] === 'white') {
                    p[w] = u;
                    DFSVisit(w, color, d, f, p)
                }
            }
            color[u] = 'black'
            f[u] = ++time;
            console.log('explored' + u)
        }
        var INF = Number.MAX_SAFE_INTEGER
        //计算最短路径的Dijkstra算法和Floyd-Warshall算法，以及计算图的最小生成树的Prim算法和Kruskal算法
        this.dijkstra = function(src) {
            var dist = [],
            visited = [],
            length = this.graph.length

            for (var i = 0; i < length; i++) {
                dist[i] = INF;
                visited[i] = false
            }
            dist[src] = 0
            for (var i = 0; i < length -1; i++) {
                var u = minDistance(dist, visited)
                visited[u] = true
                for (var v = 0; v < length; v++) {
                    if (!visited[v] && this.graph[u][v] != 0 && dist[u] !=INF && dist[u] + this.graph[u][v] < dist[v]) {
                        dist[v] = dist[u] + this.graph[u][v]
                    }
                }
            }
            return dist
        }

        var minDistance = function(dist, visited) {
            var min = INF, minIndex = -1;
            for (var v = 0; v < dist.length; v++) {
                if (visited[v] == false && dist[v] <= min){
                    min = dist[v];
                    minIndex = v
                }
                
            }
            return minIndex;
        }

        this.floydWarshall = function() {
            var dist = [],
            length = this.graph.length,
            i, 
            j,
            k
            for (i = 0; i < length; i++) {
                dist[i] = [];
                for (j = 0; j < length; j++) {
                    dist[i][j] = this.graph[i][j]
                }
            }
            for (k = 0; k < length; k++) {
                for (i = 0; i < length; i++) {
                    for (j = 0; j < length; j++) {
                        if (dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j]
                        }
                    }
                }
            }
            return dist
        }

        this.prim = function() {
            var parent = [],
            key = [],
            visited = [],
            length = this.graph.length,
            i;
            for (i = 0; i < length; i++) {
                key[i] = INF;
                visited[i] = false
            }
            key[0] = 0
            parent[0] = -1
            for (i = 0; i < length-1; i++) {
                var u  = minkey(key, visited)
                visited[u] = true
                for (var v = 0; v < length; v++) {
                    if (this.graph[u][v] && visited[v] == false && this.graph[u][v] < key[v]) {
                        parent[v] = u
                        key[v] = this.graph[u][v]
                    }
                }
            }
            return parent
        }

        this.kruskal = function() {
            var length = this.graph.length,
            parent = [],
            cost,
            ne = 0,
            a,
            b,
            u,
            v,
            i,
            j,
            min;
            cost = initializeCost()

            while (ne < length - 1) {
                for (i = 0, min = INF; i<length; i++) {
                    for (j = 0; j < length; j++) {
                        if (cost[i][j] < min) {
                            min = cost[i][j]
                            u = i
                            v = j
                        }
                    }
                }
                u = find(u, parent)
                v = find(v, parent)
                if(union(u, v, parent)) {
                    ne++
                }
                cost[u][v] = cost[v][u] = INF
            }
            return parent
        }

        var find = function(i, parent) {
            while (parent[i]) {
                i = parent[i]
            }
            return i
        }

        var union = function(i, j, parent) {
            if (i != j) {
                parent[j] = i
                return true
            }
            return false
        }

    }
    
    var graph = new Graph();
    var myVertices = ['A','B','C','D','E','F','G','H','I']; //{7}
    for (var i=0; i<myVertices.length; i++){ //{8}
        graph.addVertex(myVertices[i]);
    }
    graph.addEdge('A', 'B'); //{9}
    graph.addEdge('A', 'C');
    graph.addEdge('A', 'D');
    graph.addEdge('C', 'D');
    graph.addEdge('C', 'G');
    graph.addEdge('D', 'G');
    graph.addEdge('D', 'H');
    graph.addEdge('B', 'E');
    graph.addEdge('B', 'F');
    graph.addEdge('E', 'I');
    console.log(graph.toString());
    function printNode(value) {
        console.log('Visited vertex:' + value)
    }
    graph.bfs(myVertices[0], printNode);
    var shortestPathA = graph.BFS(myVertices[0]);
    console.log(shortestPathA);
    var formVertex = myVertices[0]
    // for (var i = 0; i < myVertices.length; i++) {
    //     var toVertex = myVertices[i];
    //     path = new Stack();
    //     for (var v = toVertex; v !== formVertex; v = shortestPathA.predcessors[v]) {
    //         path.push(v)
    //     }
    //     path.push(formVertex)
    //     var s = path.pop();
    //     while (!path.isEmpty()) {
    //         s += '-' + path.pop();
    //     }
    //     console.log(s)
    // }
    graph.dfs(printNode);
    graph.DFS();
    var graph = [[0, 2, 4, 0, 0, 0],
                [0, 0, 1, 4, 2, 0],
                [0, 0, 0, 0, 3, 0],
                [0, 0, 0, 0, 0, 2],
                [0, 0, 0, 3, 0, 2],
                [0, 0, 0, 0, 0, 0]];
    //graph.dijkstra()




    function ArrayList() {
        var array = []
        this.insert = function(item) {
            array.push(item)
        }
        this.toString = function() {
            return array.join()
        }

        this.bubbleSort = function() {
            var length = array.length
            for (var i = 0; i < length; i++) {
                for (var j = 0; j < length; j++) {
                    if (array[j] > array[j+1]) {
                        swap(array, j, j+1)
                    }
                }
            }
        }
        var swap = function(index1, index2) {
            [array[index1], array[index2]] = [array[index2], array[index1]];
            
        }

        this.selectionSort = function() {
            var length = array.length,
            indexMin;
            for (var i = 0; i < length-1; i++) {
                indexMin = 1
                for (var j = 1; j < length; j++) {
                    if (array[indexMin] > array[j]) {
                        indexMin = j
                    }
                }
                if (i != indexMin) {
                    swap(i, indexMin)
                }
            }

        }

        this.insertionSort = function() {
            var length = array.length,
            j,
            temp;
            for (var i = 1; i < length; i++) {
                j = 1 
                temp = array[i]
                while(j > 0 && array[j-1] > temp) {
                    array[j] = array[j-1];
                    j--
                }
                array[j] = temp
            }
        }

        this.mergeSort = function() {
            array = mergeSortRec(array)
        }

        var mergeSortRec = function(array) {
            var length = array.length
            if (length == 1) {
                return array
            }
            var mid  = Math.floor(length/2),
            left = array.slice(0, mid),
            right = array.slice(mid, length);

            return merge(mergeSortRec(left), mergeSortRec(right))

        }

        var merge = function (left, right) {
            var result = [],
            il = 0,
            ir = 0;
            while (il < left.length && ir < right.length) {
                if (left[il] < right[ir]) {
                    result.push(left[il++])
                } else {
                    result.push(right[ir++])
                }
            }

            while (il < left.length) {
                result.push(left[il++])
            }
            while (ir < right.length) {
                result.push(right[ir++])
            }

            return result
        }

        this.quickSort = function(){
            quick(array, 0, array.length - 1)
        }

        var quick = function(array, left, right) {
            var index;
            if (array.length > 1) {
                index = partition(array, left, right)
                if (left < index - 1) {
                    quick(array, left, index - 1)
                }
                if (index < right) {
                    quick(array, index, right)
                }
            }
        }

        var partition = function(array, left, right) {
            var pivot = array[Math.floor((right + left) / 2)],
            i = left,
            j = right;
            while (i <= j) {
                while (array[i] < pivot) {
                    i++
                }
                while (array[j] > pivot) {
                    j--
                }
                if (i <= j) {
                    swap(i,j)
                    i++
                    j--
                }
            }
            return i
        }

        this.heapSort = function() {
            var heapSize = array.length
            buildHeap(array)
            while(heapSize > 1) {
                heapSize--
                swap(0,heapSize);
                heapify(array, heapSize, 0)
            }
        }

        var buildHeap = function(array) {
            var heapSize = array.length
            for (var i = Math.floor(array.length / 2); i >= 0; i--) {
                heapify(array, heapSize, i)
            }
        }

        var heapify = function(array, heapSize, i) {
            var left = i * 2 + 1,
            right = i * 2 + 2,
            largest = i;
            if (left < heapSize && array[left] > array[largest]) {
                largest = left
            }
            if (right < heapSize && array[right] > array[largest]) {
                largest = right
            }
            if (largest !== i) {
                swap(i, largest)
                heapify(array, heapSize, largest)
            }
        }

        this.sequentialSearch = function(item) {
            for (var i = 0; i < array.length; i++) {
                if (item === array[i]) {
                    return i
                }
            }
            return -1
        }

        this.binarySearch = function(item) {
            this.quickSort()
            var low = 0,
            high = array.length - 1,
            mid,
            element;

            while (low <= high) {
                mid = Math.floor((low + high) / 2)
                element = array[mid]
                if (element < item) {
                    low = mid + 1
                } else if (element > item) {
                    high = mid - 1
                } else {
                    return mid
                }
            }
            return -1 
        }

    }

    function createNonSortedArray(size) {
        var array = new ArrayList()
        for (var i = size; i > 0; i--)  {
            array.insert(i)
        }
        return array
    }

    var array = createNonSortedArray(5); 
    console.log(array.toString()); 
    //array.bubbleSort(); 
    //array.selectionSort();
    //array.insertionSort();
    //array.mergeSort()
    //array.quickSort()
    array.heapSort()
    console.log(array.toString()); 

    function fibonacci(num) {
        if (num === 1 || num === 2) {
            return 1
        }
        return fibonacci(num - 1) + fibonacci(num - 2)
    }

    function fib(num) {
        var n1 = 1,
        n2 = 1,
        n = 1;
        for (var i = 3; i <= num; i++) {
            n = n1 + n2
            n1 = n2
            n2 = n
        }
        return n
    }

    function MinCoinChange(coins) {
        var coins = coins
        var cache = {}
        
        this.makeChange = function(amount) {
            var me = this;
            if (!amount) {
                return []
            }
            if (cache[amount]) {
                return cache[amount]
            }
            var min = [],
            newMin,
            newAmount;
            for (var i = 0; i < coins.length; i++) {
                var coin = coins[i]
                newAmount = amount - coin;
                if (newAmount >= 0) {
                    newMin = me.makeChange(newAmount)
                }
                if (newAmount >= 0 && (newMin.length < min.length-1 || !min.length) && (newMin.length || !newAmount)) {
                    min = [coin].concat(newMin)
                    console.log('new min' + min + 'for' + amount + ';newMin:' + newMin)
                }
            }
            console.log('cache',cache)
            return (cache[amount] = min)
        }
    }
    // var minCoinChange = new MinCoinChange([1, 5, 10, 25]);
    // console.log(minCoinChange.makeChange(36));
    var minCoinChange = new MinCoinChange([1, 3, 4, 25]);
    console.log(minCoinChange.makeChange(6));

    function knapSack(capacity, weights, values, n) {
        var i, w, a, b, kS = [];
        for (i = 0; i <= n; i++) {
            kS[i] = []
        }
        for (i = 0; i <= n; i++) {
            for (w = 0; w <= capacity; w++) {
                if (i === 0 || w === 0) {
                    kS[i][w] = 0
                } else if (weights[i-1] <= w) {
                    a = values[i-1] + kS[i-1][w-weights[i-1]];
                    b = kS[i-1][w]
                    kS[i][w] = (a > b) ? a : b
                } else {    
                    kS[i][w] = kS[i-1][w]
                }
            }
        }
        findValues(n, capacity, kS, weights, values)
        return kS[n][capacity]
    }

    function findValues(n, capacity, kS, weights, values) {
        var i = n, k = capacity;
        console.log('解决方案包含以下物品:')
        while (i > 0 && k > 0) {
            if (kS[i][k] != kS[i-1][k]) {
                console.log('物品' + i + '，重量' + weights[i-1] + '，价值' + values[i-1]);
                i--;
                k = k-kS[i][k]
            } else {
                i --
            }
        }
    }
    var values = [3, 4, 5],
    weights = [2, 3, 4],
    capacity = 5,
    n = values.length;
    console.log(knapSack(capacity, weights, values, n));

    function lcs(wordX, wordY) {
        var m = wordX.length,
        n = wordY.length,
        solution = [],
        l = [],
        i,
        j,
        a,
        b;
        for (i = 0; i <= m; i++) {
            l[i] = []
            solution[i] = [];
            for (j = 0; j <= n; j++) {
                l[i][j] = 0
                solution[i][j] = '0';
            }
        }
        for (i = 0; i <= m; i++) {
            for (j = 0; j <= n; j++) {
                if (i === 0 || j === 0) {
                    l[i][j] = 0
                } else if (wordX[i-1] == wordY[j-1]) {
                    l[i][j] = l[i-1][j-1] + 1
                    solution[i][j] = 'diagonal';
                } else {
                    a = l[i-1][j]
                    b = l[i][j-1];
                    l[i][j] = (a > b) ? a : b
                    solution[i][j]=(l[i][j] == l[i-1][j]) ? 'top' : 'left';
                }
            }
        }
        //printSolution(solution, l, wordX, wordY, m, n);
        return l[m][n]
    }

    function printSolution(solution, l, wordX, wordY, m, n) {
        var a = m,
        b = m,
        i,
        j,
        x = solution[a][b],
        answer = '';
        while (x != '0') {
            if (solution[a][b] === 'diagonal') {
                answer = wordX[a-1] + answer
                a--
                b--
            } else if (solution[a][b] === 'left') {
                b--
            } else if (solution[a][b] === 'top') {
                a--
            }
            x = solution[a][b]
        } 
        console.log('lcs: ' + answer)
    }
    //lcs('abcdef','cde')
    function matrixChainOrder(p, n) {
        var i, j, k, l, q, m = [];
        for (i = 1; i <= n; i++) {
            m[i] = [];
            m[i][i] = [];
        }
        var s = [];
for (i = 0; i <= n; i++) {
s[i] = [];
for (j = 0; j <= n; j++) {
s[i][j] = 0;
}
}
        for (l = 2; l < n; l++) {
            for (i = 1; i <= n-l+1; i++) {
                j = i + l -1;
                m[i][j]  = Number.MAX_SAFE_INTEGER;
                for (k = i; k <= j-1; k++) {
                    q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]
                    if (q < m[i][j]) {
                        m[i][j] = q
                        s[i][j] = k;
                    }
                }
            }
        }
        printOptimalParenthesis(s, 1, n-1);
        return m[1][n-1]
    }
    function printOptimalParenthesis(s, i, j) {
        if (i == j) {
            console.log("A[" + i + "]");
        } else {
            console.log("(");
            printOptimalParenthesis(s, i, s[i][j]);
            printOptimalParenthesis(s, s[i][j] + 1, j);
            console.log(")");
        }
    }
    var p = [10, 100, 5, 50, 1],
    n = p.length;
    console.log(matrixChainOrder(p, n));

    function MinCoinChanges(coins) {
        var coins = coins
        this.makeChange = function(amount) {
            var change = [],
            total = 0;
            for (var i = coins.length; i>=0; i--) {
                var coin = coins[i]
                while (total + coin <= amount) {
                    change.push(coin);
                    total += coin
                }
            }
            return change
        }
    }
    var minCoinChanges = new MinCoinChanges([1, 15, 20, 40]);
    console.log(minCoinChanges.makeChange(44));

    function knapSacks(capacity, values, weights) {
        var n = values.length,
        load = 0,
        i = 0,
        val = 0;

        for (i = 0; i < n && load <capacity; i++) {
            if (weights[i] <= (capacity - load)) {
                val += values[i]
                load += weights[i]
            } else {
                var r = (capacity - load) / weights[i]
                val += r * values[i]
                load += weights[i]
            }
        }
        //return w
    }
    var values = [3, 4, 5],
    weights = [2, 3, 4],
    capacity = 5;
    console.log(knapSacks(capacity, weights, values));
    </script>
</body>
</html>  
